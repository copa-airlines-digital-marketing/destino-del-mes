<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://www.copaair.com/promotions/destinations/css/bootstrap-grid.min.css">
    <link rel="stylesheet" href="https://www.copaair.com/promotions/assets/css/cm-design-system-specific.min.css">
    <link rel="stylesheet" href="https://www.copaair.com/promotions/airtrfx-lp/deals/promo-header.min.css">
    <link rel="stylesheet" href="https://www.copaair.com/promotions/airtrfx-lp/deals/coupon-highlighter.min.css">
    <link rel="stylesheet" href="https://www.copaair.com/promotions/airtrfx-lp/css/custom-pw.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://www.copaair.com/promotions/destinations/css/copa-airtrfx-full-with-fix.min.css">
    <link rel="stylesheet" href="/scss/standardPromo.css">
    <link rel="stylesheet" href="/header/scss/destinoDelMes.css ">

    <title>Destino del mes</title>
</head>

<body>

    <div id="destinoDoMes" class="cm-design-sytem styles-override">
        <div class="container mt-8 mb-6">
            <div class="lp-section">
                <div class="intro ">
                    <h2 class="text-center color-anhil  font-gilroy">
                        <strong>Aproveite nossas tarifas e viaje para <span class="color-light-blue">Jamaica</span>
                        </strong>
                    </h2>
                    <div>
                        <countdown-timer enddate="2023-10-01T00:00:00-05:00" tickrate="1000" lang="pt">
                        </countdown-timer>

                        <h3 class="text-center body-text--large  color-c200 font-gilroy">Aproveite
                            estas
                            tarifas promocionais de
                            <br><span class=" color-anhil">1 a 30 de setembro de 2023</span>
                        </h3>

                        <h3 class=" body-text--large text-center color-c200 font-gilroy ">Para viagens
                            entre<br><span class="color-anhil ">1 de setembro a 29 de fevereiro de 2023</span></h3>
                    </div>

                </div>

            </div>
        </div>
    </div>
    <script>
        ! function () {
            "use strict";

            function t() {}

            function e(t) {
                return t()
            }

            function n() {
                return Object.create(null)
            }

            function o(t) {
                t.forEach(e)
            }

            function s(t) {
                return "function" == typeof t
            }

            function r(t, e) {
                return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t
            }

            function i(t, e) {
                t.appendChild(e)
            }

            function a(t, e, n) {
                t.insertBefore(e, n || null)
            }

            function c(t) {
                t.parentNode.removeChild(t)
            }

            function l(t) {
                return document.createElement(t)
            }

            function u(t) {
                return document.createTextNode(t)
            }

            function d() {
                return u(" ")
            }

            function f(t, e, n) {
                null == n ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n)
            }

            function m(t, e) {
                e = "" + e, t.wholeText !== e && (t.data = e)
            }

            function h(t) {
                const e = {};
                for (const n of t) e[n.name] = n.value;
                return e
            }
            let p;

            function $(t) {
                p = t
            }
            const g = [],
                b = [],
                x = [],
                y = [],
                v = Promise.resolve();
            let k = !1;

            function w(t) {
                x.push(t)
            }
            const _ = new Set;
            let E = 0;

            function C() {
                const t = p;
                do {
                    for (; E < g.length;) {
                        const t = g[E];
                        E++, $(t), S(t.$$)
                    }
                    for ($(null), g.length = 0, E = 0; b.length;) b.pop()();
                    for (let t = 0; t < x.length; t += 1) {
                        const e = x[t];
                        _.has(e) || (_.add(e), e())
                    }
                    x.length = 0
                } while (g.length);
                for (; y.length;) y.pop()();
                k = !1, _.clear(), $(t)
            }

            function S(t) {
                if (null !== t.fragment) {
                    t.update(), o(t.before_update);
                    const e = t.dirty;
                    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(w)
                }
            }
            const j = new Set;

            function A(t, e) {
                -1 === t.$$.dirty[0] && (g.push(t), k || (k = !0, v.then(C)), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 |
                    0] |= 1 << e % 31
            }

            function T(r, i, a, l, u, d, f, m = [-1]) {
                const h = p;
                $(r);
                const g = r.$$ = {
                    fragment: null,
                    ctx: null,
                    props: d,
                    update: t,
                    not_equal: u,
                    bound: n(),
                    on_mount: [],
                    on_destroy: [],
                    on_disconnect: [],
                    before_update: [],
                    after_update: [],
                    context: new Map(i.context || (h ? h.$$.context : [])),
                    callbacks: n(),
                    dirty: m,
                    skip_bound: !1,
                    root: i.target || h.$$.root
                };
                f && f(g.root);
                let b = !1;
                if (g.ctx = a ? a(r, i.props || {}, ((t, e, ...n) => {
                        const o = n.length ? n[0] : e;
                        return g.ctx && u(g.ctx[t], g.ctx[t] = o) && (!g.skip_bound && g.bound[t] && g.bound[t](
                            o), b && A(r, t)), e
                    })) : [], g.update(), b = !0, o(g.before_update), g.fragment = !!l && l(g.ctx), i.target) {
                    if (i.hydrate) {
                        const t = function (t) {
                            return Array.from(t.childNodes)
                        }(i.target);
                        g.fragment && g.fragment.l(t), t.forEach(c)
                    } else g.fragment && g.fragment.c();
                    i.intro && ((x = r.$$.fragment) && x.i && (j.delete(x), x.i(y))),
                        function (t, n, r, i) {
                            const {
                                fragment: a,
                                on_mount: c,
                                on_destroy: l,
                                after_update: u
                            } = t.$$;
                            a && a.m(n, r), i || w((() => {
                                const n = c.map(e).filter(s);
                                l ? l.push(...n) : o(n), t.$$.on_mount = []
                            })), u.forEach(w)
                        }(r, i.target, i.anchor, i.customElement), C()
                }
                var x, y;
                $(h)
            }
            let M;

            function z(e) {
                let n, o, s, r, h, p;
                return {
                    c() {
                        n = l("div"), o = l("div"), s = u(e[0]), r = d(), h = l("div"), p = u(e[1]), this.c = t, f(o,
                            "class", "value"), f(h, "class", "name"), f(n, "class", "time")
                    },
                    m(t, e) {
                        a(t, n, e), i(n, o), i(o, s), i(n, r), i(n, h), i(h, p)
                    },
                    p(t, [e]) {
                        1 & e && m(s, t[0]), 2 & e && m(p, t[1])
                    },
                    i: t,
                    o: t,
                    d(t) {
                        t && c(n)
                    }
                }
            }

            function D(t, e, n) {
                let {
                    value: o
                } = e, {
                    name: s
                } = e;
                return t.$$set = t => {
                    "value" in t && n(0, o = t.value), "name" in t && n(1, s = t.name)
                }, [o, s]
            }
            "function" == typeof HTMLElement && (M = class extends HTMLElement {
                constructor() {
                    super(), this.attachShadow({
                        mode: "open"
                    })
                }
                connectedCallback() {
                    const {
                        on_mount: t
                    } = this.$$;
                    this.$$.on_disconnect = t.map(e).filter(s);
                    for (const t in this.$$.slotted) this.appendChild(this.$$.slotted[t])
                }
                attributeChangedCallback(t, e, n) {
                    this[t] = n
                }
                disconnectedCallback() {
                    o(this.$$.on_disconnect)
                }
                $destroy() {
                    ! function (t, e) {
                        const n = t.$$;
                        null !== n.fragment && (o(n.on_destroy), n.fragment && n.fragment.d(e), n
                            .on_destroy = n.fragment = null, n.ctx = [])
                    }(this, 1), this.$destroy = t
                }
                $on(t, e) {
                    const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
                    return n.push(e), () => {
                        const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                    }
                }
                $set(t) {
                    var e;
                    this.$$set && (e = t, 0 !== Object.keys(e).length) && (this.$$.skip_bound = !0, this
                        .$$set(t), this.$$.skip_bound = !1)
                }
            });

            function H(t, e, n) {
                const o = t.slice();
                return o[15] = e[n], o
            }

            function I(t) {
                let e, n, o, s, r, h, p, $ = t[15].value + "",
                    g = t[15].name + "";
                return {
                    c() {
                        e = l("div"), n = l("div"), o = u($), s = d(), r = l("div"), h = u(g), p = d(), f(n, "class",
                            "value"), f(r, "class", "name"), f(e, "class", "time")
                    },
                    m(t, c) {
                        a(t, e, c), i(e, n), i(n, o), i(e, s), i(e, r), i(r, h), i(e, p)
                    },
                    p(t, e) {
                        1 & e && $ !== ($ = t[15].value + "") && m(o, $), 1 & e && g !== (g = t[15].name + "") && m(h,
                            g)
                    },
                    d(t) {
                        t && c(e)
                    }
                }
            }

            function L(e) {
                let n, o = e[0],
                    s = [];
                for (let t = 0; t < o.length; t += 1) s[t] = I(H(e, o, t));
                return {
                    c() {
                        n = l("div");
                        for (let t = 0; t < s.length; t += 1) s[t].c();
                        this.c = t, f(n, "class", "countdown-container")
                    },
                    m(t, e) {
                        a(t, n, e);
                        for (let t = 0; t < s.length; t += 1) s[t].m(n, null)
                    },
                    p(t, [e]) {
                        if (1 & e) {
                            let r;
                            for (o = t[0], r = 0; r < o.length; r += 1) {
                                const i = H(t, o, r);
                                s[r] ? s[r].p(i, e) : (s[r] = I(i), s[r].c(), s[r].m(n, null))
                            }
                            for (; r < s.length; r += 1) s[r].d(1);
                            s.length = o.length
                        }
                    },
                    i: t,
                    o: t,
                    d(t) {
                        t && c(n),
                            function (t, e) {
                                for (let n = 0; n < t.length; n += 1) t[n] && t[n].d(e)
                            }(s, t)
                    }
                }
            }

            function N(t, e, n) {
                const o = {
                    es: {
                        years: "años",
                        months: "meses",
                        days: "días",
                        hours: "horas",
                        minutes: "minutos",
                        seconds: "segundos",
                        miliseconds: "milisegundos"
                    },
                    en: {
                        years: "years",
                        months: "months",
                        days: "days",
                        hours: "hours",
                        minutes: "minutes",
                        seconds: "seconds",
                        miliseconds: "miliseconds"
                    },
                    pt: {
                        years: "anos",
                        months: "meses",
                        days: "dias",
                        hours: "horas",
                        minutes: "minutos",
                        seconds: "segundos",
                        miliseconds: "milissegundos"
                    }
                };
                let {
                    enddate: s
                } = e, {
                    tickrate: r
                } = e, {
                    lang: i
                } = e, a = [];
                const c = (t, e) => o[t][e],
                    l = (t, e, o) => () => {
                        n(0, a = ((t, e, n) => {
                            const o = [],
                                s = Date.now(),
                                r = (t - s) / 864e5,
                                i = (t => 24 * (t - ~~t))(r),
                                a = (t => 60 * (t - ~~t))(i);
                            var l;
                            return o.push({
                                value: (~~r).toString(),
                                name: c(n, "days")
                            }), o.push({
                                value: (~~i).toString(),
                                name: c(n, "hours")
                            }), o.push({
                                value: (~~a).toString(),
                                name: c(n, "minutes")
                            }), 1e3 === e && o.push({
                                value: (l = a, ~~(60 * (l - ~~l))).toString(),
                                name: c(n, "seconds")
                            }), o
                        })(t, e, o))
                    };
                return (() => {
                    const t = parseInt(r);
                    const e = (n = s, Date.parse(n));
                    var n;
                    t || e ? setInterval(l(e, t, i), t) : console.error(
                        `Error while converting ${s} to Date or ${r} to Integer.`)
                })(), t.$$set = t => {
                    "enddate" in t && n(1, s = t.enddate), "tickrate" in t && n(2, r = t.tickrate), "lang" in t &&
                        n(3, i = t.lang)
                }, [a, s, r, i]
            }
            customElements.define("time-element", class extends M {
                constructor(t) {
                    super(), T(this, {
                        target: this.shadowRoot,
                        props: h(this.attributes),
                        customElement: !0
                    }, D, z, r, {
                        value: 0,
                        name: 1
                    }, null), t && (t.target && a(t.target, this, t.anchor), t.props && (this.$set(t
                        .props), C()))
                }
                static get observedAttributes() {
                    return ["value", "name"]
                }
                get value() {
                    return this.$$.ctx[0]
                }
                set value(t) {
                    this.$$set({
                        value: t
                    }), C()
                }
                get name() {
                    return this.$$.ctx[1]
                }
                set name(t) {
                    this.$$set({
                        name: t
                    }), C()
                }
            });
            customElements.define("countdown-timer", class extends M {
                constructor(t) {
                    super(), this.shadowRoot.innerHTML =
                        '<style>.countdown-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.countdown-container .time{-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin:0.5rem}.countdown-container .value{font-size:2rem}.countdown-container .name{font-weight:400}.countdown-container{display:flex;justify-content:center;font-family:"Gilroy";color:#0032a0;font-size:1rem;font-weight:500;text-transform:capitalize}</style>',
                        T(this, {
                            target: this.shadowRoot,
                            props: h(this.attributes),
                            customElement: !0
                        }, N, L, r, {
                            enddate: 1,
                            tickrate: 2,
                            lang: 3
                        }, null), t && (t.target && a(t.target, this, t.anchor), t.props && (this.$set(t
                            .props), C()))
                }
                static get observedAttributes() {
                    return ["enddate", "tickrate", "lang"]
                }
                get enddate() {
                    return this.$$.ctx[1]
                }
                set enddate(t) {
                    this.$$set({
                        enddate: t
                    }), C()
                }
                get tickrate() {
                    return this.$$.ctx[2]
                }
                set tickrate(t) {
                    this.$$set({
                        tickrate: t
                    }), C()
                }
                get lang() {
                    return this.$$.ctx[3]
                }
                set lang(t) {
                    this.$$set({
                        lang: t
                    }), C()
                }
            })
        }();
        //# sourceMappingURL=countdown-timer.js.map
    </script>

</body>

</html>